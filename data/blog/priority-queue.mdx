---
title: '우선순위 큐, 힙, 바이너리 힙에 대해서.'
publishedAt: '2021-10-18'
summary: '우선순위 큐와 힙, 그리고 바이너리 힙이 각각 무엇이고, 또 어떻게 쓰이는지에 대해 알아보는 글입니다.'
---

# Introduction

Mmmf... Where am I? Who am I? ... Oh, hello there, stranger.

I don't know who I am, but anyway, I'm going to discuss about priority queues.

Oh... Umm...

Yeah, as you can see in the name, it's a queue, but it isn't a
[FIFO](<https://en.wikipedia.org/wiki/FIFO_(computing_and_electronics)>) data structure. Moreover, it has priorities.
Which priorities? Well, for now, you guess it.

...

Have you guessed it? You might think, "Doesn't it use some kind of size comparison?"
Yes. It uses size comparisons, but it's more extended. What? Extended? No, never mind.
For now, I'll just discuss what a priority queue is.

# Definition

To begin with, a priority queue is a data structure that performs several operations such as peeking (or to say, getting) the top element
(I'll explain what's the top element later), popping the top element, and pushing a new element into the priority queue.

All of these operations work at a time complexity of `O(log n)`.
(The reference is [this](https://en.cppreference.com/w/cpp/container/priority_queue).)
Quite fast, huh? Oh, and you might guess, "Does it use a tree?"

Yes. It uses a tree, but not any tree. It uses a binary heap to manage its elements.

# Binary heap

[What's a binary heap?](https://en.wikipedia.org/wiki/Binary_heap)
First, a heap always has the extremest (e.g. smallest, largest) element at the root.
It keeps the order by swapping parent-child nodes when a change occurs.
And a binary heap is a heap where every element (except for leaf nodes) has exactly two children.
How does it manage the order? Well, for this one, I'll just quote Wikipedia.
(The image might look dark, so consider turning off dark mode if you are using it. Just my two cents.)

> To add an element to a heap, we can perform this algorithm:
> Add the element to the bottom level of the heap at the leftmost open space.
> Compare the added element with its parent; if they are in the correct order, stop.
> If not, swap the element with its parent and return to the previous step.
> Steps 2 and 3, which restore the heap property by comparing and possibly swapping a node with its parent, are called the up-heap operation (also known as bubble-up, percolate-up, sift-up, trickle-up, swim-up, heapify-up, or cascade-up).
> The number of operations required depends only on the number of levels the new element must rise to satisfy the heap property. Thus, the insertion operation has a worst-case time complexity of O(log n). For a random heap, and for repeated insertions, the insertion operation has an average-case complexity of O(1).
> As an example of binary heap insertion, say we have a max-heap
> ![](https://upload.wikimedia.org/wikipedia/commons/a/ac/Heap_add_step1.svg)
> and we want to add the number 15 to the heap. We first place the 15 in the position marked by the X. However, the heap property is violated since 15 > 8, so we need to swap the 15 and the 8. So, we have the heap looking as follows after the first swap:
> ![](https://upload.wikimedia.org/wikipedia/commons/1/16/Heap_add_step2.svg)
> However the heap property is still violated since 15 > 11, so we need to swap again:
> ![](https://upload.wikimedia.org/wikipedia/commons/5/51/Heap_add_step3.svg)
> which is a valid max-heap. There is no need to check the left child after this final step: at the start, the max-heap was valid, meaning the root was already greater than its left child, so replacing the root with an even greater value will maintain the property that each node is greater than its children (11 > 5; if 15 > 11, and 11 > 5, then 15 > 5, because of the transitive relation).

Long story short, it puts the new element at the bottom of the heap,
and it keeps swapping it with its parent until it complies with the comparison function.

---

Okay... so now we know that a priority queue uses a binary heap and what a binary heap is, but anyway, what are these operations?
As I said, there are three operations. However, before we discuss these operations, let's first initialize a priority queue.
Here comes the code, so don't panic. (For sake of brevity, I'll just use `int` as the element type.)

# Operations of Priority Queues

## Initialization

### Largest element on top

```cpp
#include <priority_queue>

priority_queue<int> pq;
```

Easy as cake, huh?

Now, let's dive deeper into what this really means.
First, `priority_queue` is a STL data structure. It accepts a template parameter, and we can put the type `int` there.

### Smallest element on top

However, this declaration yields a priority queue which gives the biggest element on top.
If you want the priority queue to give the smallest element on top,
you can write like this.

```cpp
#include <priority_queue>

priority_queue<int, vector<int>, greater<int>> pq;
```

What I just did is, I manually added a container to the priority queue, which is usually redundant,
but because we need to set the third parameter to `greater<int>`, I added it.
And most importantly, `greater<int>` reverses the comparison function, which makes the smallest element go on top.

**However, for custom template types, `greater<T>` should be defined.**

# Pushing elements

Now that we discussed about how to declare the priority queue, let's talk about how to actually push an element to the priority queue.

It's actually simpler than declaring a priority queue. Just type this: `pq.push(SOME_NUMBER);` Here, `SOME_NUMBER` is any number. _Fin._

# Peeking elements

We pushed an element, so what should we do next? Well, we should now peek what's on the top.
That's also simple, with just one line of code: `pq.top();`
It gives us the top element, to say, the _extreme_ element.

# Popping elements

Pushed, peeked. Now we should pop it, to make it empty. How to do it? `pq.pop();` Easy.

# Example

Now, a full example of how to use a priority queue.

```cpp:priority_queue.cpp
#include <bits/stdc++.h>

using namespace std;

priority_queue<int> pq;

int main() {
    pq.push(3);                 // pq: [3]
    pq.push(7);                 // pq: [7, 3]
    pq.push(4);                 // pq: [7, 4, 3]
    pq.push(5);                 // pq: [7, 5, 4, 3]
    pq.push(-3);                // pq: [7, 5, 4, 3, -3]
    cout << pq.top() << "\n";   // Output: "7"
    pq.pop();                   // pq: [5, 4, 3, -3]
    cout << pq.top() << "\n";   // Output: "5"
    return 0;
}
```

# Summary

To summarize, priority queues are used to get the _extreme element,_
they are internally implemented using binary heaps,
and their main three functions are `pq.push(SOME_VALUE)`, `pq.top()`, and `pq.pop()`.

I hope this summarizes well, and if you have anything to say, please leave the comments below.
It could be anything – appreciation, information, wisdom, or even humor.

Anyway, have a great day.

See you next time, bye. 🍻
